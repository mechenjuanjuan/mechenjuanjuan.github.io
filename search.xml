<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[关于Maven项目下使用Mybatis时，找不到mapper映射文件的问题]]></title>
    <url>%2F2019%2F11%2F15%2Fchen_05%2F</url>
    <content type="text"><![CDATA[一般maven项目，dao的mapper映射文件会映射在resources下，创建同包同名的xml，这样是没问题的 如下图：如果想在这个地方放xml，就找不到mapper映射文件了 可以查看项目下的\target\classes的映射文件，这我就不展示了 解决方法 在pom.xml的build里添加 12345678910111213141516171819202122&lt;plugins&gt; &lt;!-- 资源文件拷贝插件 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt; &lt;version&gt;2.7&lt;/version&gt; &lt;configuration&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;!-- 如果不添加此节点，mybatis的mapper.xml文件都会被漏掉。 --&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt; 注意： 刷新一下maven，然后clean,install一下，启动项目 我启动项目报错了，不知道你们会不会，报错显示找不到spring_mvc.xml 我想大概是之前默认映射是在resources目录下，修改映射路径过滤之后就找不到了 然后我有添加了一段映射路径，就不报错了 代码如下： 1234567891011121314151617181920212223242526272829303132&lt;build&gt; &lt;plugins&gt; &lt;!-- 资源文件拷贝插件 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt; &lt;version&gt;2.7&lt;/version&gt; &lt;configuration&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;!-- 如果不添加此节点，mybatis的mapper.xml文件都会被漏掉。 --&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/build&gt; 以上是我自己的理解，当然是亲自测试过的 希望对你们有帮助]]></content>
      <categories>
        <category>Idea</category>
        <category>Maven</category>
        <category>Mybatis</category>
        <category>mapper</category>
      </categories>
      <tags>
        <tag>Idea</tag>
        <tag>Maven</tag>
        <tag>Mybatis</tag>
        <tag>mapper</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Idea创建Maven项目]]></title>
    <url>%2F2019%2F11%2F15%2Fchen_04%2F</url>
    <content type="text"><![CDATA[1、Idea创建 填写组名、项目名 选择你的maven和本地仓库 注：maven环境，配置，本地仓库就不说了 解决构建maven项目过慢 选择项目地址 看到如下图的信息和目录结构说明构建成功 在src/main下创建java和resources 在src下创建test文件，再创建java和resources用于测试 目录结构创建好了，图标颜色样式如下图 1、maven相关设置 注意：如果maven项目控制台输出的是乱码，可以在这个地方设置，解决乱码 -Dfile.encoding=GB2312 -Darchetypecatalog=internal maven仓库设置，和仓库更新 1、maven项目启动在pom.xml配置tomcat7,JDK插件 1234567891011121314151617181920212223242526272829&lt;build&gt; &lt;!--maven插件--&gt; &lt;plugins&gt; &lt;!--jdk编译插件--&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;encoding&gt;utf-8&lt;/encoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;!--tomcat插件--&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;!-- tomcat7的插件， 不同tomcat版本这个也不一样 --&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.1&lt;/version&gt; &lt;configuration&gt; &lt;!-- 通过maven tomcat7:run运行项目时，访问项目的端口号 --&gt; &lt;port&gt;8080&lt;/port&gt; &lt;!-- 项目访问路径 本例：localhost:9090, 如果配置的aa， 则访问路径为localhost:9090/aa--&gt; &lt;path&gt;/&lt;/path&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 出现如下图，说明配置成功（不成功刷新一下maven） 可以直接点击tomcat7：run运行 为了启动方便，可以再配置一下 清除一下，安装部署一下 启动，下面会出现访问地址，点击访问 注：访问地址可以在pom.xml的插件里修改 修改后台代码，配置文件等，尽量clean、install一下再启动 未完待续…]]></content>
      <categories>
        <category>Idea</category>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>Idea</tag>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java调用Python传list(多个list，不同类型list)参数]]></title>
    <url>%2F2019%2F10%2F30%2Fchen_03%2F</url>
    <content type="text"><![CDATA[1、通过Runtime进行调用1.1 传一个字符串 java文件12345678910111213141516171819202122232425262728public class CoalType &#123; public static String coalType_list(String data) &#123; String arr = null; try &#123; String[] arg = new String[] &#123; &quot;E:\\Program Files\\Python36\\python.exe&quot;, &quot;E:\\Test\\test\\qiting.py&quot;,data&#125;; Process proc = Runtime.getRuntime().exec(arg);// 执行py文件 BufferedReader in = new BufferedReader(new InputStreamReader(proc.getInputStream())); String line = null; while ((line = in.readLine()) != null) &#123; arr = line; &#125; in.close(); proc.waitFor(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; return arr; &#125; public static void main(String[] args) &#123; String data = &quot;Lisa&quot;; String test_name = CoalType.coalType_list(data); System.out.println(test_name); &#125;&#125; py文件 12345678import numpy as npimport sys as ss def main(): print (ss.argv[1])if __name__ == &apos;__main__&apos;: main() 结果 1Lisa 如下图： &ensp;&ensp;&ensp;在Java中通过Runtime调用Python程序与直接执行Python程序的效果是一样的，可以在Python中读取传递的参数，也可以在Java中读取到Python的执行结果。&ensp;&ensp;&ensp;如上图所示，这样是获取不到数据的，需要输出语句print，StartStopOpt方法在java中也调用不了，需要在.py文件里初始化调用，然后输出，java才能获取到数据&ensp;&ensp;&ensp;需要注意的是，不能在Python中通过return语句返回结果，只能将返回值写入到标准输出流中，然后在Java中通过标准输入流读取Python的输出值。 1.1 传一个list集合 java文件 12345678910111213141516171819202122232425262728293031323334public class Mogun &#123; public static String coalType_list(List&lt;Double&gt; list_one) &#123; String arr = null; try &#123; String sysPython = &quot;E:\\Program Files\\Python36\\python.exe &quot;; String filePython = &quot;E:\\Test\\test\\qiting.py &quot;; Process proc = Runtime.getRuntime().exec(sysPython + filePython + list_one);// 执行py文件 BufferedReader in = new BufferedReader(new InputStreamReader(proc.getInputStream())); String line = null; while ((line = in.readLine()) != null) &#123; arr = line; &#125; in.close(); proc.waitFor(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; return arr; &#125; public static void main(String[] args) throws Exception &#123; List&lt;Double&gt; list_one = new ArrayList&lt;&gt;(); list_one.add(1.222); list_one.add(2.888); list_one.add(3.888); list_one.add(4.888); list_one.add(5.888); String flag = Mogun.coalType_list(list_one); System.out.println(flag); &#125;&#125; py文件 1234567891011121314151617181920212223242526import numpy as npimport sys as ssdef StartStopOpt(list_str,list_float): ............ ........... return result def main(): list_str = [] list_float = [] for i in range(1, len(ss.argv)): list_str.append(ss.argv[i].replace(&quot;,&quot;, &quot;&quot;)) list_str[0] = list_str[0].replace(&quot;[&quot;, &quot;&quot;) list_str[len(ss.argv) - 2] = list_str[len(ss.argv) - 2].replace(&quot;]&quot;, &quot;&quot;) # 字符串数组 # print(list_str) # 浮点数数组 list_int = list(map(float, list_str)) # print(list_int) # 调用函数传参得到返回值输出 test = StartStopOpt(list_str,list_float) print(test) if __name__ == &apos;__main__&apos;: main() 结果 123456字符串数组[&apos;1.222&apos;, &apos;2.888&apos;, &apos;3.888&apos;, &apos;4.888&apos;, &apos;5.888&apos;]浮点数数组[1.222, 2.888, 3.888, 4.888, 5.888]调用函数传参得到返回值输出...省略 注意：一定要记得空格，不然会报错 1.1 传两个list集合 java文件 12345678910111213141516171819202122232425262728293031323334353637383940public class Mogun &#123; public static String coalType_list(List&lt;Double&gt; list_one, List&lt;Integer&gt; list_two) &#123; String arr = null; try &#123; String sysPython = &quot;E:\\Program Files\\Python36\\python.exe &quot;; String filePython = &quot;E:\\Test\\test\\qiting.py &quot;; Process proc = Runtime.getRuntime().exec(sysPython + filePython + list_one + list_two);// 执行py文件 BufferedReader in = new BufferedReader(new InputStreamReader(proc.getInputStream())); String line = null; while ((line = in.readLine()) != null) &#123; arr = line; &#125; in.close(); proc.waitFor(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; return arr; &#125; public static void main(String[] args) throws Exception &#123; List&lt;Double&gt; list_one = new ArrayList&lt;&gt;(); list_one.add(1.222); list_one.add(2.888); list_one.add(3.888); list_one.add(4.888); list_one.add(5.888); List&lt;Integer&gt; list_two = new ArrayList&lt;&gt;(); list_two.add(1); list_two.add(2); list_two.add(3); list_two.add(4); list_two.add(5); String flag = Mogun.coalType_list(list_one, list_two); System.out.println(flag); &#125;&#125; py文件 123456789101112131415161718192021222324252627282930313233343536import numpy as npimport sys as ssdef StartStopOpt(turn,current): ............ ........... return result def main(): #初始数据 # print (ss.argv[1:]) list_str = [] turn = [] current = [] for i in range(1, len(ss.argv)): list_str.append(ss.argv[i].replace(&quot;,&quot;, &quot;&quot;)) list_str[0] = list_str[0].replace(&quot;[&quot;, &quot;&quot;) list_str[len(ss.argv) - 2] = list_str[len(ss.argv) - 2].replace(&quot;]&quot;, &quot;&quot;) str = &apos;,&apos;.join(list_str) arr = str.split(&quot;][&quot;) turn = arr[0].split(&quot;,&quot;) turn = list(map(float, turn))#转换成浮点数数组 #输出第一个数组 # print (turn) current = arr[1].split(&quot;,&quot;) current = list(map(int, current))#转换成整数数组 #输出第二个数组 # print (current) # 调用函数传参得到返回值输出 test = StartStopOpt(turn,current) print(test) if __name__ == &apos;__main__&apos;: main() 结果 12345678初始数据[&apos;[1.222,&apos;, &apos;2.888,&apos;, &apos;3.888,&apos;, &apos;4.888,&apos;, &apos;5.888][1,&apos;, &apos;2,&apos;, &apos;3,&apos;, &apos;4,&apos;, &apos;5]&apos;]输出第一个数组[1, 2, 3, 4, 5]输出第二个数组[1.222, 2.888, 3.888, 4.888, 5.888]调用函数传参得到返回值输出...省略 问题：数组的长度也是有限制的，我试着添加了8000元素的double类型的集合，就报错了解决：https://www.cnblogs.com/downmoon/archive/2012/11/18/2775587.html]]></content>
      <categories>
        <category>Java</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git使用详情（二）]]></title>
    <url>%2F2019%2F10%2F14%2Fchen_02%2F</url>
    <content type="text"><![CDATA[1、远程仓库1.1 添加远程库上一篇我们已经在本地创建了一个Git仓库，又想让其他人来协作开发，此时就可以把本地仓库同步到远程仓库，同时还增加了本地仓库的一个备份。常用的远程仓库就是github：https://github.com/，接下来我们演示如何将本地代码同步到github。 1.1.1 在github上创建仓库首先你得在github上创建一个账号，这个就不演示了。然后在github上创建一个仓库： 点击“create repository”按钮仓库就创建成功了。 Github支持两种同步方式“https”和“ssh”。如果使用https很简单基本不需要配置就可以使用，但是每次提交代码和下载代码时都需要输入用户名和密码。如果使用ssh方式就需要客户端先生成一个密钥对，即一个公钥一个私钥。然后还需要把公钥放到githib的服务器上。这两种方式在实际开发中都用应用，所以我们都需要掌握。接下来我们先看ssh方式。 1.1.2 ssh协议1.1.2.1 什么是ssh?SSH 为 Secure Shell（安全外壳协议）的缩写，由 IETF 的网络小组（Network Working Group）所制定。SSH 是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。 1.1.2.2 基于密匙的安全验证使用ssh协议通信时，推荐使用基于密钥的验证方式。你必须为自己创建一对密匙，并把公用密匙放在需要访问的服务器上。如果你要连接到SSH服务器上，客户端软件就会向服务器发出请求，请求用你的密匙进行安全验证。服务器收到请求之后，先在该服务器上你的主目录下寻找你的公用密匙，然后把它和你发送过来的公用密匙进行比较。如果两个密匙一致，服务器就用公用密匙加密“质询”（challenge）并把它发送给客户端软件。客户端软件收到“质询”之后就可以用你的私人密匙解密再把它发送给服务器。 1.1.2.3 ssh密钥生成在windows下我们可以使用 Git Bash.exe来生成密钥，可以通过开始菜单或者右键菜单打开Git Bash git bash 执行命令,生命公钥和私钥 命令: ssh-keygen -t rsa 执行命令完成后,在window本地用户.ssh目录C:\Users\用户名\.ssh下面生成如下名称的公钥和私钥: 1.1.2.4 ssh密钥配置密钥生成后需要在github上配置密钥本地才可以顺利访问。 在key部分将id_rsa.pub文件内容添加进去，然后点击“Add SSH key”按钮完成配置。 1.1.3 同步到远程仓库同步到远程仓库可以使用git bash也可以使用tortoiseGit 1.1.3.1 使用git bash在仓库所在的目录（D:\temp\git\repository）点击右键选择“Git Bash Here”，启动git bash程序。 然后在git bash中执行如下语句： git remote add origin git@github.com:sublun/mytest.git git push -u origin master 注意：其中红色字体部分需要替换成个人的用户名。 如何出现如下错误： 可以先执行如下命令，然后再执行上面的命令 $ git remote rm origin 1.1.3.2 使用TortoiseGit同步一、由于TortoiseGit使用的ssh工具是“PuTTY”git Bash使用的ssh工具是“openSSH”，如果想让TortoiseGit也使用刚才生成的密钥可以做如下配置： Url：远程仓库的地址 推送URL：也是相同的 Putty密钥：选择刚才生成的密钥中的私钥 二、同步。在本地仓库的文件夹中单击右键，选择“Git同步” 1.2 从远程仓库克隆克隆远程仓库也就是从远程把仓库复制一份到本地，克隆后会创建一个新的本地仓库。选择一个任意部署仓库的目录，然后克隆远程仓库。 1.2.1 使用git bash： $ git clone git@github.com:sublun/mytest.git 1.2.2 使用TortoiseGit：在任意目录点击右键: 1.3 从远程仓库取代码Git中从远程的分支获取最新的版本到本地有这样2个命令：1.git fetch：相当于是从远程获取最新版本到本地，不会自动merge（合并代码）2.git pull：相当于是从远程获取最新版本并merge到本地上述命令其实相当于git fetch 和 git merge在实际使用中，git fetch更安全一些因为在merge前，我们可以查看更新情况，然后再决定是否合并如果使用TortoiseGit的话可以从右键菜单中点击“拉取”（pull）或者“获取”（fetch） 1.4 搭建私有Git服务器1.4.1 服务器搭建远程仓库实际上和本地仓库没啥不同，纯粹为了7x24小时开机并交换大家的修改。GitHub就是一个免费托管开源代码的远程仓库。但是对于某些视源代码如生命的商业公司来说，既不想公开源代码，又舍不得给GitHub交保护费，那就只能自己搭建一台Git服务器作为私有仓库使用。搭建Git服务器需要准备一台运行Linux的机器，在此我们使用CentOS。以下为安装步骤：yum -y install curl curl-devel zlib-devel openssl-devel perl cpio expat-devel gettext-devel gcc cc2、下载git-2.5.0.tar.gz1）解压缩2）cd git-2.5.03）autoconf4）./configure5）make6）make install3、添加用户adduser -r -c ‘git version control’ -d /home/git -m git此命令执行后会创建/home/git目录作为git用户的主目录。5、设置密码passwd git输入两次密码6、切换到git用户su git7、创建git仓库git –bare init /home/git/first注意：如果不使用“–bare”参数，初始化仓库后，提交master分支时报错。这是由于git默认拒绝了push操作，需要.git/config添加如下代码：[receive] denyCurrentBranch = ignore推荐使用：git –bare init初始化仓库。 1.4.2 连接服务器私有git服务器搭建完成后就可以向连接github一样连接使用了，但是我们的git服务器并没有配置密钥登录，所以每次连接时需要输入密码。使用命令连接：$ git remote add origin ssh://git@192.168.25.156/home/git/first这种形式和刚才使用的形式好像不一样，前面有ssh://前缀，好吧你也可以这样写：$ git remote add origin git@192.168.25.156:first 使用TortoiseGit同步的话参考上面的使用方法。 2、分支管理2.1 创建合并分支在我们每次的提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即master分支。HEAD指针严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支。一开始的时候，master分支是一条线，Git用master指向最新的提交，再用HEAD指向master，就能确定当前分支，以及当前分支的提交点： 每次提交，master分支都会向前移动一步，这样，随着你不断提交，master分支的线也越来越长。 当我们创建新的分支，例如dev时，Git新建了一个指针叫dev，指向master相同的提交，再把HEAD指向dev，就表示当前分支在dev上： 你看，Git创建一个分支很快，因为除了增加一个dev指针，改改HEAD的指向，工作区的文件都没有任何变化！ 不过，从现在开始，对工作区的修改和提交就是针对dev分支了，比如新提交一次后，dev指针往前移动一步，而master指针不变： 假如我们在dev上的工作完成了，就可以把dev合并到master上。Git怎么合并呢？最简单的方法，就是直接把master指向dev的当前提交，就完成了合并： 所以Git合并分支也很快！就改改指针，工作区内容也不变！ 合并完分支后，甚至可以删除dev分支。删除dev分支就是把dev指针给删掉，删掉后，我们就剩下了一条master分支： 2.2 使用TortoiseGit实现分支管理使用TortoiseGit管理分支就很简单了。 2.2.1 创建分支在本地仓库文件夹中点击右键，然后从菜单中选择“创建分支”： 如果想创建完毕后直接切换到新分支可以勾选“切换到新分支”选项或者从菜单中选择“切换/检出”来切换分支： 2.2.2 合并分支分支切换到dev后就可以对工作区的文件进行修改，然后提交到dev分支原理的master分支不受影响。例如我们修改mytest.txt中的内容，然后提交到dev分支。 切换到master分支后还是原理的内容： 将dev分支的内容合并到master分支，当前分支为master。从右键菜单中选择“合并”： 再查看mytest.txt的内容就已经更新了： 2.3 解决冲突两个分支中编辑的内容都是相互独立互不干扰的，那么如果在两个分支中都对同一个文件进行编辑，然后再合并，就有可能会出现冲突。例如在master分支中对mytest.txt进行编辑： 然后提交到版本库。 切换到dev分支，对mytest.txt进行编辑： 最后进行分支合并，例如将dev分支合并到master分支。需要先切换到master分支然后进行分支合并。 出现版本冲突。 冲突需要手动解决。 在冲突文件上单机右键选择“解决冲突”菜单项： 把冲突解决完毕的文件提交到版本库就可以了。 3、在IntelliJ IDEA中使用git3.1 在Idea中配置git安装好IntelliJ IDEA后，如果Git安装在默认路径下，那么idea会自动找到git的位置，如果更改了Git的安装位置则需要手动配置下Git的路径。选择File→Settings打开设置窗口，找到Version Control下的git选项： 选择git的安装目录后可以点击“Test”按钮测试是否正确配置。 3.2 将工程添加至git1）在idea中创建一个工程，例如创建一个java工程，名称为idea-git-test，如下图所示： 2）创建本地仓库 在菜单中选择“vcs”→Import into Version Control→Create Git Repository... 选择工程所在的上级目录。本例中应该选择idea-projects目录，然后点击“OK”按钮，在工程的上级目录创建本地仓库，那么idea-projects目录就是本地仓库的工作目录，此目录中的工程就可以添加到本地仓库中。也就是可以把idea-git-test工程添加到本地仓库中。 选择之后在工具栏上就多出了git相关工具按钮: 3）将工程添加至本地仓库 直接点击commit按钮，将工程提交至本地仓库。 然后点击“commit”按钮，将工程添加至本地仓库。 4）推送到远程在github上创建一个仓库然后将本地仓库推送到远程。在工程上点击右键，选择git→Repository→push，或者在菜单中选择vcs→git→push 点击“Define remote”链接，配置https形式的URL，git形式的无法通过。然后点击OK 点击“push”按钮就讲本地仓库推送到远程，如果是第一次配置推送需要输入github的用户名和密码。 3.3 从远程仓库克隆关闭工程后，在idea的欢迎页上有“Check out from version control”下拉框，选择git 此处仍然推荐使用htts形式的url，点击“test”按钮后显示连接成功。 点击OK按钮后根据提示将远程仓库克隆下来，然后倒入到idea中。 3.4 从服务端拉取代码如果需要从服务端同步代码可以使用工具条中的“update”按钮]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>Svn</tag>
        <tag>Idea</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git使用详情（一）]]></title>
    <url>%2F2019%2F10%2F10%2Fchen_01%2F</url>
    <content type="text"><![CDATA[1、Git与Svn对比1.1 Svn&ensp;&ensp;&ensp;SVN是集中式版本控制系统，版本库是集中放在中央服务器的，而干活的时候，用的都是自己的电脑，所以首先要从中央服务器哪里得到最新的版本，然后干活，干完后，需要把自己做完的活推送到中央服务器。集中式版本控制系统是必须联网才能工作，如果在局域网还可以，带宽够大，速度够快，如果在互联网下，如果网速慢的话，就郁闷了。&ensp;&ensp;&ensp;下图就是标准的集中式版本控制工具管理方式： &ensp;&ensp;&ensp;集中管理方式在一定程度上看到其他开发人员在干什么，而管理员也可以很轻松掌握每个人的开发权限。 &ensp;&ensp;&ensp;但是相较于其优点而言，集中式版本控制工具缺点很明显： 服务器单点故障 容错性差 1.2 Git&ensp;&ensp;&ensp;Git是分布式版本控制系统，那么它就没有中央服务器的，每个人的电脑就是一个完整的版本库，这样，工作的时候就不需要联网了，因为版本都是在自己的电脑上。既然每个人的电脑都有一个完整的版本库，那多个人如何协作呢？比如说自己在电脑上改了文件A，其他人也在电脑上改了文件A，这时，你们两之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。&ensp;&ensp;&ensp;下图就是分布式版本控制工具管理方式： 2、Git工作流程一般工作流程如下：&ensp;&ensp;&ensp;1．从远程仓库中克隆 Git 资源作为本地仓库。&ensp;&ensp;&ensp;2．从本地仓库中checkout代码然后进行代码修改&ensp;&ensp;&ensp;3．在提交前先将代码提交到暂存区。&ensp;&ensp;&ensp;4．提交修改。提交到本地仓库。本地仓库中保存修改的各个历史版本。&ensp;&ensp;&ensp;5．在修改完成后，需要和团队成员共享代码时，可以将代码push到远程仓库。下图展示了 Git 的工作流程： 3、Git的安装最早Git是在Linux上开发的，很长一段时间内，Git也只能在Linux和Unix系统上跑。不过，慢慢地有人把它移植到了Windows上。现在，Git可以在Linux、Unix、Mac和Windows这几大平台上正常运行了。由于开发机大多数情况都是windows，所以本教程只讲解windows下的git的安装及使用。 3.1 软件下载下载地址：https://git-scm.com/download 参考资料中安装包已经下载完毕，根据不同的操作系统选择对应的安装包。 3.2软件安装3.2.1 安装git for windows 一路“下一步”使用默认选项即可。 3.2.2 安装TortoiseGit 一路“下一步”使用默认选项即可。 默认选项下会启动配置画面： 由于目前只有英文语言包，默认即可继续下一步。 配置git.exe，在3.2.1中已经安装过git-for-windows了所以在此找到git.exe所在的目录。 配置开发者姓名及邮箱，每次提交代码时都会把此信息包含到提交的信息中。 使用默认配置，点击“完成”按钮完成配置。 完整完毕后在系统右键菜单中会出现git的菜单项。 3.2.3 安装中文语言包安装中文语言包并不是必选项。可以根据个人情况来选择安装。 直接“下一步”完整完毕。 语言包安装完毕后可以在TortoiseGit的设置中调整语言 4、使用Git管理文件版本4.1 创建版本库&ensp;&ensp;&ensp;什么是版本库呢？版本库又名仓库，英文名repository，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。由于git是分布式版本管理工具，所以git在不需要联网的情况下也具有完整的版本管理能力。&ensp;&ensp;&ensp;创建一个版本库非常简单，可以使用git bash也可以使用tortoiseGit。首先，选择一个合适的地方，创建一个空目录（D:\temp\git\repository）。 4.1.1 使用GitBash在当前目录中点击右键中选择Git Bash来启动。 或者在开始菜单中启动。注意如果是从开始菜单启动的gitbash需要切换目录到仓库所在的目录。 创建仓库执行命令： $ git init 4.1.2 使用GitBash使用TortoiseGit时只需要在目录中点击右键菜单选择“在这里创建版本库” 版本库创建成功，会在此目录下创建一个.git的隐藏目录，如下所示： 在windows中如何显示隐藏目录隐藏目录请自行百度 **o(╯□╰)o** 概念：版本库：“.git”目录就是版本库，将来文件都需要保存到版本库中。工作目录：包含“.git”目录的目录，也就是.git目录的上一级目录就是工作目录。只有工作目录中的文件才能保存到版本库中。 4.2 添加文件4.2.1 添加文件过程在D:\temp\git\repository目录下创建一个mytest.txt文件 文本文件变为带“+”号的图标： 提交文件：在mytest.txt上再次点击右键选择“提交”，此时将文件保存至版本库中。 4.2.2 工作区和暂存区&ensp;&ensp;&ensp;Git和其他版本控制系统如SVN的一个不同之处就是有暂存区的概念。什么是工作区（Working Directory）？&ensp;&ensp;&ensp;工作区就是你在电脑里能看到的目录，比如我的reporstory文件夹就是一个工作区。&ensp;&ensp;&ensp;有的人可能会说repository不是版本库吗怎么是工作区了？其实repository目录是工作区，在这个目录中的“.git”隐藏文件夹才是版本库。这回概念清晰了吧。&ensp;&ensp;&ensp;Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。如下图所示： 分支和HEAD的概念我们稍后再讲。前面讲了我们把文件往Git版本库里添加的时候，是分两步执行的： &ensp;&ensp;&ensp;第一步是用git add把文件添加进去，实际上就是把文件修改添加到暂存区；&ensp;&ensp;&ensp;第二步是用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支。&ensp;&ensp;&ensp;因为我们创建Git版本库时，Git自动为我们创建了唯一一个master分支，所以，现在，git commit就是往master分支上提交更改。你可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。 4.3 修改文件4.3.1 提交修改被版本库管理的文件不可避免的要发生修改，此时只需要直接对文件修改即可。修改完毕后需要将文件的修改提交到版本库。在mytest.txt文件上点击右键，然后选择“提交” 4.3.2 查看修改历史在开发过程中可能会经常查看代码的修改历史，或者叫做修改日志。来查看某个版本是谁修改的，什么时间修改的，修改了哪些内容。可以在文件上点击右键选择“显示日志”来查看文件的修改历史。 4.3.3 差异比较当文件内容修改后，需要和修改之前对比一下修改了哪些内容此时可以使用“比较差异功能” 4.3.4 还原修改当文件修改后不想把修改的内容提交，还想还原到未修改之前的状态。此时可以使用“还原”功能 注意：此操作会撤销所有未提交的修改，所以当做还原操作是需要慎重慎重！！！ 4.4 删除文件需要删除无用的文件时可以使用git提供的删除功能直接将文件从版本库中删除。 4.5 例子：将java工程提交到版本库第一步：将参考资料中的java工程project-test复制到工作目录中 第二步：将工程添加到暂存区。 点击确定完成暂存区添加。 三、忽略文件或文件夹&ensp;&ensp;&ensp;在此工程中，并不是所有文件都需要保存到版本库中的例如“bin”目录及目录下的文件就可以忽略。好在Git考虑到了大家的感受，这个问题解决起来也很简单，在Git工作区的根目录下创建一个特殊的.gitignore文件，然后把要忽略的文件名填进去，Git就会自动忽略这些文件。如果使用TortoiseGit的话可以使用菜单项直接进行忽略。 选择保留本地文件。完成后在此文件夹内会多出一个.gitignore文件，这个文件就是文件忽略文件，当然也可以手工编辑。其中的内容就是把bin目录忽略掉。 四、提交代码 将代码添加到master分支上，其中.gitignore文件也需要添加到暂存区，然后提交到版本库。 4.6忽略文件语法规范空行或是以 # 开头的行即注释行将被忽略。可以在前面添加正斜杠 / 来避免递归,下面的例子中可以很明白的看出来与下一条的区别。可以在后面添加正斜杠 / 来忽略文件夹，例如 build/ 即忽略build文件夹。可以使用 ! 来否定忽略，即比如在前面用了 *.apk ，然后使用 !a.apk ，则这个a.apk不会被忽略。 用来匹配零个或多个字符，如 *.[oa] 忽略所有以”.o”或”.a”结尾， *~ 忽略所有以 ~ 结尾的文件（这种文件通常被许多编辑器标记为临时文件）； [] 用来匹配括号内的任一字符，如 [abc] ，也可以在括号内加连接符，如 [0-9] 匹配0至9的数； ? 用来匹配单个字符。 看了这么多，还是应该来个栗子： 忽略 .a 文件 *.a 但否定忽略 lib.a, 尽管已经在前面忽略了 .a 文件 !lib.a 仅在当前目录下忽略 TODO 文件， 但不包括子目录下的 subdir/TODO /TODO 忽略 build/ 文件夹下的所有文件 build/ 忽略 doc/notes.txt, 不包括 doc/server/arch.txt doc/*.txt 忽略所有的 .pdf 文件 在 doc/ directory 下的 doc/*/.pdf]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>Svn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo 部署到码云]]></title>
    <url>%2F2019%2F09%2F09%2Fchen_two%2F</url>
    <content type="text"><![CDATA[注册码云 码云官网：https://gitee.com/ 注册完成后创建一个新仓库，如下图 创建完成后，查看路径 设置密钥 我是直接使用https的，ssh我就不详细说了 复制到hexo根目录下_config.yml的这个位置 然后通过Git Bash Here 123hexo cleanhexo ghexo d 上传的时候系统会有弹框叫你输入你的码云用户名和密码 设置Page服务访问博客 代码成功上传码云后 部署目录和自定义域名可空，右边有免费试用版的 这个路径访问的时候可能会出现无法访问此网站或者404亦或者图标，样式，图片没效果？ 解决： 复制这两个地方 到hexo根目录下_config.yml里的这个位置 在进行那三条命令，上传到码云，刷新就有了 1如果还不能出现博客页面，再更新一下pages服务]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
        <tag>码云</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo部署到Coding]]></title>
    <url>%2F2019%2F09%2F04%2Fchen_one%2F</url>
    <content type="text"><![CDATA[需要安装的工具我就不多介绍了 注册Coding Cdoing官网：https://coding.net/ 注册完成后创建一个新项目，如下图 1项目名称、项目描述随意填写。然后点击创建。 配置SSH 在电脑桌面右键，打开Git Bash Here，检查是否已经有SSH Key，输入1cd ~/.ssh 出现bash: cd: /c/Users/Administrator/.ssh: No such file or directory 。说明没有.ssh这个目录 如果没有.ssh这个目录，则我们生成一个SSH，输入 1ssh-keygen -t rsa -C &quot;你的邮箱&quot; 接下来几步中系统会要你输入密码 (不设置密码的可以直接按三次回车)Enter passphrase (empty for no passphrase):&lt;输入密码&gt;Enter same passphrase again:&lt;再次输入密码&gt; 1这个密码是在你提交项目给服务器的时候使用的，可以为空，如果为空的话提交项目时则不用输入密码就能提交。 看到类似这样的界面，就表示成功生成ssh key了 然后查看公钥 1cat ~/.ssh/id_rsa.pub 将这些内容复制到这个地方，如下图： 然后直接把刚才复制的内容粘贴进去,点击添加即可。 测试SSh是否配置成功 在Git Bash Here 中输入 1ssh -T git@git.coding.net 如果显示以下则说明coding中的ssh配置成功 1Hello username You&apos;ve connected to Coding.net by SSH successfully! 如下图显示(权限被拒绝)不要慌： 也可能出现无法建立真实性的问题： 123The authenticity of host &apos;git.coding.net (118.25.166.124)&apos; can&apos;t be established.RSA key fingerprint is SHA256:jok3FH7q5LJ6qvE7iPNehBgXRw51ErE77S0Dn+Vg/Ik.Are you sure you want to continue connecting (yes/no)? 解决：首次建立链接会要求信任主机，在Git Bash Here 中输入 1ssh -T git@e.coding.net yes回车 配置hexo 打开hexo站点根目录 打开Coding新建的项目，找到这个地方，复制路径，如下图 然后在_config.yml修改配置 配置完，执行以下命令 123hexo cleanhexo ghexo d 成功如下 查看部署的成功的代码 静态访问 网站名称随便取，复制路径在浏览器访问即可 自定义域名（有域名者）]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Coding</tag>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[茉莉雨]]></title>
    <url>%2F2019%2F08%2F16%2FRaindrops%2F</url>
    <content type="text"><![CDATA[垂柳斜向茉莉雨 向晚伴残笛 宣白落笔全是你 文细腻字飘逸人无语 梧桐秋风沙沙地 孤窗外疑是你 故事远去几华里 等结局我犹豫轻叹气 琴声里愁几许关于你 轻弹一首别离还在爱你 缘份竟然默许你离去 轻弹一首别离名为茉莉雨 园中花瓣落地了断了过去 而我酝酿情绪举杯引醉意 烛火摇曳皆因风起 泪晕墨迹我在想你 枫红愁绪秋冷了回忆 轻弹一首别离放不下你 吟唱心事秘密伤继续 轻弹一首别离名为茉莉雨 雨季后我溯溪找你的消息 古镇老墙添绿又一年过去 庭院开满茉莉却等不到你]]></content>
      <categories>
        <category>Other</category>
      </categories>
      <tags>
        <tag>无题</tag>
        <tag>茉莉雨</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F08%2F15%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>Other</category>
      </categories>
      <tags>
        <tag>Hello</tag>
      </tags>
  </entry>
</search>
